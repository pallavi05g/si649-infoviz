<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<script src="http://d3js.org/d3.v3.min.js"></script>
<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body>
<script type="text/javascript">
		
//Width and height of map
var width = 840;
var height = 500;

var stateClicked = '';

// D3 Projection
var projection = d3.geo.albersUsa()
				   .translate([width/2, height/2])    // translate to center of screen
				   .scale([1000]);          // scale things down so see entire US
        
// Define path generator
var path = d3.geo.path()               // path generator that will convert GeoJSON to SVG paths
		  	 .projection(projection);  // tell path generator to use albersUsa projection

		
// Define linear scale for output
var color = d3.scale.linear()
			  .range(["rgb(213,222,217)","rgb(69,173,168)","rgb(79,200,97)","rgb(217,91,67)"]);

var legendText = ["Cities Lived", "States Lived", "States Visited", "Nada"];

//Create SVG element and append map to the SVG
var svg = d3.select("body")
			.append("svg")
			.attr("width", width)
			.attr("height", height);
        
// Append Div for tooltip to SVG
var div = d3.select("body")
		    .append("div")   
    		.attr("class", "tooltip")               
    		.style("opacity", 0);
    
// Load in my states data!
d3.csv("states-lived.csv", function(data) {
color.domain([0,1,2,3]); // setting the range of the input data

// Load GeoJSON data and merge with states data
d3.json("us-states.json", function(json) {
//console.log(data)
// Loop through each state data value in the .csv file
for (var i = 0; i < data.length; i++) {
//    console.log("YO");
	// Grab State Name
	var dataState = data[i].state;

	// Grab data value 
	var dataValue = data[i].visited;

	// Find the corresponding state inside the GeoJSON
	for (var j = 0; j < json.features.length; j++)  {
		var jsonState = json.features[j].properties.name;

		if (dataState == jsonState) {

		// Copy the data value into the JSON
		json.features[j].properties.visited = dataValue; 

		// Stop looking through the JSON
		break;
		}
	}
}

// Bind the data to the SVG and create one path per GeoJSON feature
svg.selectAll("path")
	.data(json.features)
	.enter()
	.append("path")
	.attr("d", path)
	.style("stroke", "#fff")
	.style("stroke-width", "1")
	.style("fill", function(d) {

	// Get data value
	var value = d.properties.visited;

	if (value) {
	//If value exists…
	return color(value);
	} else {
	//If value is undefined…
	return "rgb(213,222,217)";
	}})
    .on("click", function(d){
        stateClicked = d.properties.name;
        console.log("Hello "+stateClicked); // In Map chart
        stateChecker(stateClicked);
    });
		 
// Map the cities I have lived in!
d3.csv("cities-lived.csv", function(data) {

svg.selectAll("circle")
	.data(data)
	.enter()
	.append("circle")
	.attr("cx", function(d) {
		return projection([d.lon, d.lat])[0];
	})
	.attr("cy", function(d) {
		return projection([d.lon, d.lat])[1];
	})
	.attr("r", function(d) {
		return Math.sqrt(d.years) * 4;
	})
		.style("fill", "rgb(217,91,67)")	
		.style("opacity", 0.85)	

	.on("mouseover", function(d) {      
    	div.transition()        
      	   .duration(200)      
           .style("opacity", .9);      
           div.text(d.place)
           .style("left", (d3.event.pageX) + "px")     
           .style("top", (d3.event.pageY - 28) + "px");    
	})   

    // fade out tooltip on mouse out               
    .on("mouseout", function(d) {       
        div.transition()        
           .duration(500)      
           .style("opacity", 0);   
    });
});  
        
var legend = d3.select("body").append("svg")
      			.attr("class", "legend")
     			.attr("width", 140)
    			.attr("height", 200)
   				.selectAll("g")
   				.data(color.domain().slice().reverse())
   				.enter()
   				.append("g")
     			.attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });

  	legend.append("rect")
   		  .attr("width", 18)
   		  .attr("height", 18)
   		  .style("fill", color);

  	legend.append("text")
  		  .data(legendText)
      	  .attr("x", 24)
      	  .attr("y", 9)
      	  .attr("dy", ".35em")
      	  .text(function(d) { return d; });
	});

});

/*Multiple Line Charts*/
    
var margin = {top: 20, right: 80, bottom: 30, left: 50},
width = 720 - margin.left - margin.right,
height = 300 - margin.top - margin.bottom;

var parseDate = d3.time.format("%Y%m%d").parse;

var x = d3.time.scale()
    .range([0, width]);

var y = d3.scale.linear()
    .range([height, 0]);

var color1 = d3.scale.category10();

var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");

var line = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.count); });

var svg1 = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

/*This function returns state wise stats for each category across years as well as totals across categories for each state. The stateClicked variable is passed from the map and is used to fetch state wise results. Use this function to draw dynamic line/bar charts on the right*/
function stateChecker(stateClicked){
    d3.tsv("data-allyears-statewise.csv", function(error, data, key) {
        for (var i = 0; i < data.length; i++){
            if (stateClicked == data[i]['State']){
                console.log("Matched");
                console.log(data[i]);
                console.log("State: " +data[i]['State']+" Race: "+data[i]['RaceT']+" Religion: "+data[i]['ReligionT']+" SexualOrientation: "+data[i]['SexualOrientationT']+" Disability: "+data[i]['DisabilityT']+" Gender: "+data[i]['GenderT']+" GenderIdentity: "+data[i]['GenderIdentityT']);
            }
        }
        var year; // fetch from slider?
        var categories; //hate crime types
        
        year = 2016;
    
        //fetches respective years' data for each hate crime type, need to figure out why it is looping 6 times, TO DO    
        if(year == 2013){
            categories = color1.domain().map(function(name) {
                return {
                    values: data.map(function(d) {
                        return {state: d['State'], race: +d['Race13'], religion: +d['Religion13'], sexualorientation: +d['SexualOrientation13'], disability: +d['Disability13'], gender: +d['Gender13'], genderidentity: +d['GenderIdentity13']};})
                };
            }); 
        }else if(year == 2014){
            categories = color1.domain().map(function(name) {
                return {
                    values: data.map(function(d) {
                        return {state: d['State'], race: +d['Race14'], religion: +d['Religion14'], sexualorientation: +d['SexualOrientation14'], disability: +d['Disability14'], gender: +d['Gender14'], genderidentity: +d['GenderIdentity14']};})
                };
            });             
        }else if(year == 2015){
            categories = color1.domain().map(function(name) {
                return {
                    values: data.map(function(d) {
                        return {state: d['State'], race: +d['Race15'], religion: +d['Religion15'], sexualorientation: +d['SexualOrientation15'], disability: +d['Disability15'], gender: +d['Gender15'], genderidentity: +d['GenderIdentity15']};})
                };
            });             
        }else if(year == 2016){
            categories = color1.domain().map(function(name) {
                return {
                    values: data.map(function(d) {
                        return {state: d['State'], race: +d['Race16'], religion: +d['Religion16'], sexualorientation: +d['SexualOrientation16'], disability: +d['Disability16'], gender: +d['Gender16'], genderidentity: +d['GenderIdentity16']};})
                };
            });             
        }else{
        categories = color1.domain().map(function(name) {
        return {
          values: data.map(function(d) {
            return {state: d['State'], race: +d['RaceT'], religion: +d['ReligionT'], sexualorientation: +d['SexualOrientationT'], disability: +d['DisabilityT'], gender: +d['GenderT'], genderidentity: +d['GenderIdentityT']};})
        };
      }); 
    }
        console.log(categories);    
        x.domain(d3.extent(data, function(d) { return d.state; }));
        
        //calculate min and max values in the categories list of key value pairs-- TO DO 
        y.domain([
            d3.min(categories, function(c) { return d3.min(c.values, function(v) { return v.count; }); }),
            d3.max(categories, function(c) { return d3.max(c.values, function(v) { return v.count; }); })
      ]);
        svg1.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);
        
        svg1.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Counts");
        
    var category = svg1.selectAll(".category")
      .data(categories)
    .enter().append("g")
      .attr("class", "category");

//TO DO from here --- When a user clicks on a state, the associated category wise data for all years must be plotted on line chart such that each dot indicates the year across categories just like the sample. Different colors are used to indicate category types. As of now, the function fetches state that the user clicks. The year is used to get necessary values but all of them are plotted at once (2013, 2014, 2015, 2016). CategoryT (Eg: RaceT indicates total count across years for the race category)  --- See sample line chart below   
        function samp(d){
            console.log(d[1]['State']);
        }
        samp(data);

    category.append("path")
      .attr("class", "line")
      .attr("d", function(d) { return line(d.values); })
      .style("stroke", function(d) { return color1(d.state); });
    
   category.append("text")
      .datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
      .attr("transform", function(d) { return "translate(" + x(d.value.date) + "," + y(d.value.count) + ")"; })
      .attr("x", 3)
      .attr("dy", ".35em")
      .text(function(d) { return d.name; });

  category.selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 3)
    .attr("cx", function(d) { return x(d.date); })
    .attr("cy", function(d) { return y(d.count); })
    .style("fill", function(d,i,j) { return color1(categories[j].name); })
    .on('click', function(d){
      console.log('clicked');
    });     
    //console.log(category);
    });
    

}

// Sample line chart
d3.tsv("data.csv", function(error, data) {
  color1.domain(d3.keys(data[0]).filter(function(key) { return key !== "date"; }));

  data.forEach(function(d) {
    d.date = parseDate(d.date);
  });

  var categories = color1.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {date: d.date, count: +d[name]};
      })
    };
  });  

  x.domain(d3.extent(data, function(d) { return d.date; }));

  y.domain([
    d3.min(categories, function(c) { return d3.min(c.values, function(v) { return v.count; }); }),
    d3.max(categories, function(c) { return d3.max(c.values, function(v) { return v.count; }); })
  ]);

  svg1.append("g")
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis);

  svg1.append("g")
      .attr("class", "y axis")
      .call(yAxis)
    .append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 6)
      .attr("dy", ".71em")
      .style("text-anchor", "end")
      .text("Counts");

  var category = svg1.selectAll(".category")
      .data(categories)
    .enter().append("g")
      .attr("class", "category");

  category.append("path")
      .attr("class", "line")
      .attr("d", function(d) { return line(d.values); })
      .style("stroke", function(d) { return color1(d.name); });

  category.append("text")
      .datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
      .attr("transform", function(d) { return "translate(" + x(d.value.date) + "," + y(d.value.count) + ")"; })
      .attr("x", 3)
      .attr("dy", ".35em")
      .text(function(d) { return d.name; });

  category.selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 3)
    .attr("cx", function(d) { return x(d.date); })
    .attr("cy", function(d) { return y(d.count); })
    .style("fill", function(d,i,j) { return color1(categories[j].name); })
    .on('click', function(d){
      console.log('clicked');
    });

});
    
</script>
</body>
</html>
